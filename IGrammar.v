From stdpp Require Export list.

Section IGrammar.

(*
  An Infix Expression Grammar is a CFG where all productions have the following form:

  A = LEX       (atomic expressions)
  A = A op A    (infix expressions)

  A is the only nonterminal in the grammar. LEX and op are terminals, such that no operand
  symbol op, is LEX.

  In Coq, we define an infix expression grammar is as two types L (LEX) and O (op).
  Every possible instance l of L gives a production A = l. Similarly, every possible instance
  o of O gives a production A = A o A.
 *)


(* A word is a list of terminal symbols. *)
Definition word L O := list (L + O).

Inductive parse_tree L O :=
  (* Atomic Nodes for atomic expressions. The leaves of the parse tree. *)
  | ANode : L -> parse_tree L O
  (* Infix Nodes for infix expressions. *)
  | INode : parse_tree L O -> O -> parse_tree L O -> parse_tree L O.

(* Implicit Types t : parse_tree. *)

Arguments ANode {_ _} _.
Arguments INode {_ _} _ _ _.

(* yield pt gives the left-to-right concatenation of all the leaves of pt. *)
Fixpoint yield {L O} t : word L O :=
  match t with
  | ANode lex => [inl lex]
  | INode t1 op t2 => yield t1 ++ inr op :: yield t2
  end.

(* language w states that w is a sentence in the language generated by the grammar. *)
Definition language {L O} (w : list (L + O)) : Prop :=
  exists (t : parse_tree L O), yield t = w.

Inductive tree_pattern O :=
  (* Nonterminal pattern node. *)
  | HPatt : tree_pattern O
  (* Infix pattern node. *)
  | IPatt : tree_pattern O -> O -> tree_pattern O -> tree_pattern O.

Arguments HPatt {_}.
Arguments IPatt {_} _ _ _.

(* Implicit Types q : tree_pattern.
Implicit Types qs : tree_pattern -> Prop. *)

(* matches t q states that parse tree t matches the tree pattern q. *)
Inductive matches {L O} : parse_tree L O -> tree_pattern O -> Prop :=
  (* Every parse tree matches the nonterminal pattern node. *)
  | HMatch t :
      matches t HPatt
  (* Infix nodes match the infix pattern node only if its subtrees match and the operand
     word is equal. *)
  | IMatch t1 t2 q1 q2 o :
      matches t1 q1 ->
      matches t2 q2 -> 
      matches (INode t1 o t2) (IPatt q1 o q2).

(* matches t qs states that parse tree t matches one of the tree patterns in qs. *)
Definition matches_set {L O} (t : parse_tree L O) (Q : tree_pattern O -> Prop) : Prop :=
  exists q : tree_pattern O, Q q /\ matches t q.

(* valid qs t states that a parse tree and all its subtrees should not match
   any patterns in qs. *)
Inductive conflict_free {L O} (Q : tree_pattern O -> Prop) : parse_tree L O -> Prop :=
  | ANode_cfree l :
      conflict_free Q (ANode l)
  | INode_cfree t1 o t2 :
      ~ matches_set (INode t1 o t2) Q ->
      conflict_free Q t1 ->
      conflict_free Q t2 ->
      conflict_free Q (INode t1 o t2).

Record drules O := mkDrules {
  prio : O -> O -> Prop;
  left_a : O -> O -> Prop;
  right_a : O -> O -> Prop;
}.

Arguments prio {_} _ _ _.
Arguments left_a {_} _ _ _.
Arguments right_a {_} _ _ _.

Record drules_dec {O} (pr : drules O) := mkDrules_dec {
  dec_prio : forall (o1 : O) (o2 : O), Decision (pr.(prio) o1 o2);
  dec_left_a : forall (o1 : O) (o2 : O), Decision (pr.(left_a) o1 o2);
  dec_right_a : forall (o1 : O) (o2 : O), Decision (pr.(right_a) o1 o2)
}.

Definition CL {O} (o1 o2 : O) : tree_pattern O :=
  IPatt (IPatt HPatt o2 HPatt) o1 HPatt.
Definition CR {O} (o1 o2 : O) : tree_pattern O :=
    IPatt HPatt o1 (IPatt HPatt o2 HPatt).

Inductive conflict_pattern {O} (pr : drules O) : tree_pattern O -> Prop :=
  | CPrio1 o1 o2 :
      pr.(prio) o1 o2 ->
      conflict_pattern pr (CL o1 o2)
  | CPrio2 o1 o2 :
      pr.(prio) o1 o2 ->
      conflict_pattern pr (CR o1 o2)
  | CLeft o1 o2 : 
      pr.(left_a) o1 o2 ->
      conflict_pattern pr (CR o1 o2)
  | CRight o1 o2 : 
      pr.(right_a) o1 o2 ->
      conflict_pattern pr (CL o1 o2).

Definition dlanguage {L O} (pr : drules O) (w : list (L + O)) : Prop :=
  exists t : parse_tree L O, yield t = w /\ conflict_free (conflict_pattern pr) t.

Definition safe {L O} (pr : drules O) : Prop :=
  forall w : list (L + O), language w -> dlanguage pr w.

Record safety_props {O} (pr : drules O) := mkSafety_props {
  prio_antisym o1 o2 : pr.(prio) o1 o2 -> ~ pr.(prio) o2 o1;

  left_a_sym o1 o2 : pr.(left_a) o1 o2 -> pr.(left_a) o2 o1;
  right_a_sym o1 o2 : pr.(right_a) o1 o2 -> pr.(right_a) o2 o1;

  prio_one o1 o2 : pr.(prio) o1 o2 -> ~ pr.(left_a) o1 o2 /\ ~ pr.(right_a) o1 o2;
  left_a_one o1 o2 : pr.(left_a) o1 o2 -> ~ pr.(prio) o1 o2 /\ ~ pr.(right_a) o1 o2;
  right_a_one o1 o2 : pr.(right_a) o1 o2 -> ~ pr.(prio) o1 o2 /\ ~ pr.(left_a) o1 o2
}.

Inductive linsert_one {L O} (pr : drules O) (l1 : L) (o1 : O) : 
      parse_tree L O -> parse_tree L O -> Prop :=
  | ANode_LInsert_One l2 :
      linsert_one pr l1 o1 (ANode l2) (INode (ANode l1) o1 (ANode l2))
  | INode_LInsert_One_1 t1 o2 t2 :
      ~ conflict_pattern pr (CR o1 o2) ->
      linsert_one pr l1 o1 (INode t1 o2 t2)
        (INode (ANode l1) o1 (INode t1 o2 t2))
  | INode_LInsert_One_2 t1 o2 t2 t1' :
      conflict_pattern pr (CR o1 o2) ->
      linsert_one pr l1 o1 t1 t1' ->
      linsert_one pr l1 o1 (INode t1 o2 t2)
        (INode t1' o2 t2).

Inductive linsert {L O} (pr : drules O):
      parse_tree L O -> O -> parse_tree L O -> parse_tree L O -> Prop :=
  | ANode_LInsert l o t t' :
      linsert_one pr l o t t' ->
      linsert pr (ANode l) o t t'
  | INode_LInsert t1 o1 t2 o2 t t' t'' :
      linsert pr t2 o2 t t' ->
      linsert pr t1 o1 t' t'' ->
      linsert pr (INode t1 o1 t2) o2 t t''.

Inductive fix_tree {L O} (pr : drules O) :
      parse_tree L O -> parse_tree L O -> Prop :=
  | ANode_fix l :
      fix_tree pr (ANode l) (ANode l)
  | INode_fix t1 o t2 t2' t' :
      fix_tree pr t2 t2' ->
      linsert pr t1 o t2' t' ->
      fix_tree pr (INode t1 o t2) t'.

End IGrammar.
