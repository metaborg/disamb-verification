From stdpp Require Export list.
From stdpp Require Export relations.

Section IGrammar.

(*
  An Infix Expression Grammar is a CFG where all productions have the following form:

  A = LEX       (atomic expressions)
  A = A op A    (infix expressions)

  A is the only nonterminal in the grammar. LEX and op are terminals, such that no operand
  symbol op, is LEX.

  In Coq, we define an infix expression grammar is as two types L (LEX) and O (op).
  Every possible instance l of L gives a production A = l. Similarly, every possible instance
  o of O gives a production A = A o A.
 *)


(* A word is a list of terminal symbols. *)
Definition word L O := list (L + O).

Inductive parse_tree L O :=
  (* Atomic Nodes for atomic expressions. The leaves of the parse tree. *)
  | ANode : L -> parse_tree L O
  (* Infix Nodes for infix expressions. *)
  | INode : parse_tree L O -> O -> parse_tree L O -> parse_tree L O.

Global Arguments ANode {_ _} _.
Global Arguments INode {_ _} _ _ _.

(* [yield t] gives the left-to-right concatenation of all the leaves of t. *)
Fixpoint yield {L O} t : word L O :=
  match t with
  | ANode lex => [inl lex]
  | INode t1 op t2 => yield t1 ++ inr op :: yield t2
  end.

(* [language w] states that [w] is a sentence in the language generated by the grammar. *)
Definition language {L O} (w : word L O) : Prop :=
  exists (t : parse_tree L O), yield t = w.

Inductive tree_pattern O :=
  (* Nonterminal pattern node. *)
  | HPatt : tree_pattern O
  (* Infix pattern node. *)
  | IPatt : tree_pattern O -> O -> tree_pattern O -> tree_pattern O.

Global Arguments HPatt {_}.
Global Arguments IPatt {_} _ _ _.

(* [matches t q] states that parse tree [t] matches the tree pattern [q]. *)
Inductive matches {L O} : parse_tree L O -> tree_pattern O -> Prop :=
  (* Every parse tree matches the nonterminal pattern node. *)
  | HMatch t :
      matches t HPatt
  (* Infix nodes match the infix pattern node only if its subtrees match and the operand
     word is equal. *)
  | IMatch t1 t2 q1 q2 o :
      matches t1 q1 ->
      matches t2 q2 -> 
      matches (INode t1 o t2) (IPatt q1 o q2).

(* [matches_set t qs] states that parse tree t matches one of the tree patterns in qs. *)
Definition matches_set {L O} (t : parse_tree L O) (Q : tree_pattern O -> Prop) : Prop :=
  exists q : tree_pattern O, Q q /\ matches t q.

(* [conflict_free qs t] states that parse tree [t] and all its subtrees should not match
   any patterns in [qs]. *)
Inductive conflict_free {L O} (Q : tree_pattern O -> Prop) : parse_tree L O -> Prop :=
  | ANode_cfree l :
      conflict_free Q (ANode l)
  | INode_cfree t1 o t2 :
      ~ matches_set (INode t1 o t2) Q ->
      conflict_free Q t1 ->
      conflict_free Q t2 ->
      conflict_free Q (INode t1 o t2).

(* Definition for disambiguation rules. Since we identify infix production using operator
   [O], these rules will be defined over these infix operators. *)
Record drules (O : Type) := mkDrules {
  (* Priority *)
  prio : O -> O -> Prop;
  (* Left-Associativity *)
  left_a : O -> O -> Prop;
  (* Right-Associativity *)
  right_a : O -> O -> Prop;

  (* The following three properties state that all disambiguation rules are decidable. *)
  prio_dec : RelDecision prio;
  left_a_dec : RelDecision left_a;
  right_a_dec : RelDecision right_a;
}.
Global Existing Instances prio_dec left_a_dec right_a_dec.

Global Arguments prio {_} _ _ _.
Global Arguments left_a {_} _ _ _.
Global Arguments right_a {_} _ _ _.

(* The two commonly used types of tree patterns that will be used throughout the code base. *)
Definition CL {O} (o1 o2 : O) : tree_pattern O :=
  IPatt (IPatt HPatt o2 HPatt) o1 HPatt.
Definition CR {O} (o1 o2 : O) : tree_pattern O :=
  IPatt HPatt o1 (IPatt HPatt o2 HPatt).

(* [conflict_pattern pr q] states that [q] is a conflict-pattern generated by
   the disambiguation rules [pr]. Using currying, you can obtain the entire set of conflict-patterns
   using [conflict_pattern pr], which we will commonly use throughout the code base. *)
Inductive conflict_pattern {O} (pr : drules O) : tree_pattern O -> Prop :=
  | CPrio1 (o1 o2 : O) :
      pr.(prio) o1 o2 ->
      conflict_pattern pr (CL o1 o2)
  | CPrio2 o1 o2 :
      pr.(prio) o1 o2 ->
      conflict_pattern pr (CR o1 o2)
  | CLeft o1 o2 : 
      pr.(left_a) o1 o2 ->
      conflict_pattern pr (CR o1 o2)
  | CRight o1 o2 : 
      pr.(right_a) o1 o2 ->
      conflict_pattern pr (CL o1 o2).

(* [dlanguage pr w] states that [w] is a sentence in the disambiguated language,
   generated by the grammar and disambiguation rules [pr]. *)
Definition dlanguage {L O} (pr : drules O) (w : word L O) : Prop :=
  exists t : parse_tree L O, yield t = w /\ conflict_free (conflict_pattern pr) t.

(* [safe pr] states that the disambiguated language generated by [pr] is safe. Meaning
   that [pr] preserves the language of the grammar. *)
Definition safe L {O} (pr : drules O) : Prop :=
  forall w : word L O, language w -> dlanguage pr w.

(* [complete pr] states that the disambiguated language generated by [pr] is unambiguous.
   Meaning there is at most one conflict-free parse tree for each sentence in the grammar. *)
Definition complete L {O} (pr : drules O) : Prop :=
  forall t1 t2 : parse_tree L O,
    yield t1 = yield t2 ->
    conflict_free (conflict_pattern pr) t1 ->
    conflict_free (conflict_pattern pr) t2 ->
    t1 = t2.

(* [safe_pr pr] states that [pr] itself is safe. i.e. it imposes restrictions on [pr] such
   that [safe pr] should hold. *)
Definition safe_pr {O} (pr : drules O) : Prop :=
  forall o1 o2,
    (pr.(prio) o1 o2 \/ pr.(left_a) o1 o2) ->
    (pr.(prio) o2 o1 \/ pr.(right_a) o2 o1) -> False.

(* [complete_pr pr] states that [pr] itself  is complete. i.e. it imposes restrictions on [pr] such
   that [complete pr] should hold. *)
Record complete_pr {O} (pr : drules O) := mkComplete_pr {
  complete_1 : forall o1 o2,
    pr.(prio) o1 o2 \/ pr.(left_a) o1 o2 \/
    pr.(prio) o2 o1 \/ pr.(right_a) o2 o1;

  complete_2 : forall o1 o2 o3,
    pr.(prio) o1 o2 -> pr.(prio) o2 o3 -> pr.(prio) o1 o3;

  complete_3 : forall o1 o2 o3,
    pr.(prio) o1 o2 -> pr.(prio) o2 o3 -> pr.(prio) o1 o3;
  complete_4 : forall o1 o2 o3,
    pr.(prio) o1 o2 -> pr.(left_a) o2 o3 -> pr.(prio) o1 o3;
  complete_5 : forall o1 o2 o3,
    pr.(prio) o1 o2 -> pr.(right_a) o2 o3 -> pr.(prio) o1 o3;
  complete_6 : forall o1 o2 o3,
    pr.(left_a) o1 o2 -> pr.(prio) o2 o3 -> pr.(prio) o1 o3;

  complete_7 : forall o1 o2 o3,
    pr.(left_a) o1 o2 -> pr.(left_a) o2 o3 -> pr.(left_a) o1 o3;

  complete_8 : forall o1 o2 o3,
    pr.(left_a) o1 o2 -> pr.(right_a) o2 o3 -> False;
}.

End IGrammar.


Section IGrammarRepair.

(* This section introduces functions that will help proving safety and completeness. *)

Definition is_conflict_pattern {O} (pr : drules O) (q : tree_pattern O) :=
  match q with
  | IPatt (IPatt HPatt o2 HPatt) o1 HPatt =>
      if decide (pr.(prio) o1 o2) then true
      else if decide (pr.(right_a) o1 o2) then true
      else false
  | IPatt HPatt o1 (IPatt HPatt o2 HPatt) =>
      if decide (pr.(prio) o1 o2) then true
      else if decide (pr.(left_a) o1 o2) then true
      else false
  | _ => false
  end.

(* One-Left-Insertion. It inserts a single lexical and operator symbol on the left-most side
   of the tree, trying not to introduce a conflict. *)
Fixpoint linsert_one {L O} (pr : drules O) l1 o t2 : parse_tree L O :=
  match t2 with
  | ANode l2 => INode (ANode l1) o (ANode l2)
  | INode t2_1 o2 t2_2 =>
      if is_conflict_pattern pr (CR o o2)
      then INode (linsert_one pr l1 o t2_1) o2 t2_2
      else INode (ANode l1) o (INode t2_1 o2 t2_2)
  end.

(* Left-Insertion. Recursively (in a right-to-left order) left-inserts each lexical and operator
   symbol from a tree into a target tree. *)
Fixpoint linsert {L O} (pr : drules O) t1 o t2 : parse_tree L O :=
  match t1 with
  | ANode l => linsert_one pr l o t2
  | INode t11 o1 t12 => linsert pr t11 o1 (linsert pr t12 o t2)
  end.

(* Repair uses left-insertion to fix all conflicts from a tree. *)
Fixpoint repair {L O} (pr : drules O) t : parse_tree L O :=
  match t with
  | ANode l => ANode l
  | INode t1 o t2 => linsert pr t1 o (repair pr t2)
  end.

(* Simple-Left-Insertion is a dumbed-down variant of Left-Insertion. It behaves exactly as
   One-Left-Insertion, except it inserts an entire tree immediately rather than just a single
   lexical symbol. This function will be helpful when proving completeness. *)
Fixpoint simpleton_linsert {L O} (pr : drules O) t1 o t2 : parse_tree L O :=
  match t2 with
  | ANode l2 => INode t1 o (ANode l2)
  | INode t21 o2 t22 =>
      if is_conflict_pattern pr (CR o o2)
      then INode (simpleton_linsert pr t1 o t21) o2 t22
      else INode t1 o (INode t21 o2 t22)
  end.

(* Build works the same way as Repair, with the exception that it takes a yield as input
   rather than a parse tree. If the input list is not well-formed, then [None] is returned.
   This function will be helpful in proving completeness. *)
Fixpoint build {L O} (pr : drules O) (w : word L O) : option (parse_tree L O) :=
  match w with
  | [inl l] => Some (ANode l)
  | inl l :: inr o :: w =>
      match (build pr w) with
      | None => None
      | Some t => Some (linsert_one pr l o t)
      end
  | _ => None
  end.

(* [yield_struct w] states that [w] is well-formed for usage in the [build] function. *)
Inductive yield_struct {L O} : word L O -> Prop :=
  | LYield l :
      yield_struct [inl l]
  | LOYield l o w :
      yield_struct w ->
      yield_struct (inl l :: inr o :: w).

End IGrammarRepair.
