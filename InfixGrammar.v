Require Import List.
Import ListNotations.
Require Import Psatz.
Load "Lib/StrongInduction".

Ltac inv H := inversion H; clear H; subst.


(*
  An Infix Expression Grammar is a CFG where all productions have the following form:

  A = LEX       (atomic expressions)
  A = A op A    (infix expressions)

  A is the only nonterminal in the grammar. LEX and op are terminals, such that no operand
  symbol op, is LEX.

  In Coq, we define an infix expression grammar is as two types L (LEX) and O (op).
  Every possible instance l of L gives a production A = l. Similarly, every possible instance
  o of O gives a production A = A o A.
 *)


(* A word is a list of terminal symbols. *)
Definition word (L O : Type) := list (L + O).

Inductive parse_tree (L O : Type) :=
  (* Atomic Nodes for atomic expressions. The leaves of the parse tree. *)
  | ANode : L -> parse_tree L O
  (* Infix Nodes for infix expressions. *)
  | INode : parse_tree L O -> O -> parse_tree L O -> parse_tree L O.

Arguments ANode {_ _} _.
Arguments INode {_ _} _ _ _.

(* yield pt gives the left-to-right concatenation of all the leaves of pt. *)
Fixpoint yield {L O} (pt : parse_tree L O) : word L O :=
  match pt with
  | ANode lex => [inl lex]
  | INode pt1 op pt2 => yield pt1 ++ inr op :: yield pt2
  end.

(* language w states that w is a sentence in the language generated by the grammar. *)
Definition language {L O} (w : word L O) : Prop :=
  exists pt, yield pt = w. 

Inductive tree_pattern (O : Type) :=
  (* Nonterminal pattern node. *)
  | NTPatt
  (* Infix pattern node. *)
  | IPatt : tree_pattern O -> O -> tree_pattern O -> tree_pattern O.

Arguments NTPatt {_}.
Arguments IPatt {_} _ _ _.

(* matches tp pt states that parse tree pt matches the tree pattern tp. *)
Inductive matches {L O} : tree_pattern O -> parse_tree L O -> Prop :=
  (* Every parse tree matches the nonterminal pattern node. *)
  | NT_match pt :
      matches NTPatt pt
  (* Infix nodes match the infix pattern node only if its subtrees match and the operand
     word is equal. *)
  | INode_match tp1 tp2 pt1 pt2 o :
      matches tp1 pt1 ->
      matches tp2 pt2 -> 
      matches (IPatt tp1 o tp2) (INode pt1 o pt2).

(* sub_matches tp pt states that there is a subtree in pt that matches tp. *)
Inductive sub_matches {L O} : tree_pattern O -> parse_tree L O -> Prop :=
  (* If tp matches pt. *)
  | Head_match tp pt :
      matches tp pt ->
      sub_matches tp pt
  (* Left subtree of pt if its an infix node. *)
  | LSub_match tp pt1 o pt2 :
      sub_matches tp pt1 ->
      sub_matches tp (INode pt1 o pt2)
  (* Right subtree of pt if its an infix node. *)
  | RSub_match tp pt1 o pt2 :
      sub_matches tp pt2 ->
      sub_matches tp (INode pt1 o pt2).

(* Disambiguation rules for Infix Expression Grammars *)
Record dgrammar (O : Type) := mkDgrammar {
  left_assoc : O -> O -> Prop
}.

Arguments left_assoc {_} _ _.

(* valid_pt g pt states that the parse tree follows all disambiguation rules specified
   in g. *)
Definition valid_pt {L O} (g : dgrammar O) (pt : parse_tree L O) : Prop :=
  forall o1 o2, g.(left_assoc) o1 o2 ->
    (* For left-associativity: No subtree should match the pattern A[NT o1 A[NT o2 NT]]. *)
    ~ sub_matches (IPatt NTPatt o1 (IPatt NTPatt o2 NTPatt)) pt.

(* dlanguage g w states that w is a sentence in the disambiguated language generated by g. *)
Definition dlanguage {L O} (g : dgrammar O) (w : word L O) : Prop :=
  exists pt,
    yield pt = w /\ valid_pt g pt.

(* size pt gives the number of infix nodes in the parse tree. *)
Fixpoint size {L O} (pt : parse_tree L O) : nat :=
  match pt with
  | ANode _ => 0
  | INode pt1 _ pt2 => S (size pt1 + size pt2)
  end.


Section InfixGrammarTheorems.
Context {L O : Type}.
Implicit Types l : L.
Implicit Types g : dgrammar O.
Implicit Types pt : parse_tree L O.
Implicit Types w : word L O.

(* If a parse tree is valid, then its subtrees are also valid. *)
Lemma valid_pt_valid_st g pt1 pt2 o :
  valid_pt g (INode pt1 o pt2) -> valid_pt g pt1 /\ valid_pt g pt2.
Proof.
  (* Simple direct proof by using the definition of subtree matching. *)
  unfold valid_pt.
  intros.
  split; intros; intro N; destruct H with (o1 := o1) (o2 := o2).
  - assumption.
  - apply LSub_match.
    assumption.
  - assumption.
  - apply RSub_match.
    assumption.
Qed.

(* For every parse tree, we can construct a parse tree that is
    - valid
    - has the same yield
    - has the same size
  
  We are only interested in the yield and valid parse tree, but the lemma has been made
  stronger to allow for a better induction hypothesis.

  NOTATION: We write pt' with the prime to denote the 'transformed' parse trees.
*)
Lemma safety_pt n g pt :
  size pt = n ->
  exists pt', size pt' = size pt /\ yield pt' = yield pt /\ valid_pt g pt'.
Proof.
  (* Proof by (strong) induction over the size of the parse tree. *)
  revert pt.
  strong induction n. intros.

  destruct pt as [lex|pt1 op1 pt2]; simpl in *.
  
  (* BASE CASE: pt = ANode lex *)
  - exists (ANode lex).
    split; [|split].
    + reflexivity.
    + reflexivity.
    + unfold valid_pt.
      intros.
      intro N.
      inv N.
      inv H2.

  (* INDUCTIVE CASE: pt = INode pt1 pt2 *)
  - (* pt1' is the valid version of pt1 *)
    destruct H with (n0 := size pt1) (pt := pt1) as (pt1'&[??]); [lia|reflexivity|].
    destruct H2.
    (* pt2' is the valid version of pt2 *)
    destruct H with (n0 := size pt2) (pt := pt2) as (pt2'&[??]); [lia|reflexivity|].
    destruct H5.

    destruct pt2' as [lex|pt2' op2 pt3']; simpl in *.
    (* CASE: pt2' = ANode lex *)
    + exists (INode pt1' op1 (ANode lex)).
      split; [|split].
      * simpl.
        lia.
      * simpl.
        rewrite H2.
        rewrite H5.
        reflexivity.
      * unfold valid_pt.
        intros.
        intro N.
        inv N.
        ** inv H8.
           inv H15.
        ** destruct H3 with (o1 := o1) (o2 := o2); assumption.
        ** inv H10.
           inv H0.

    (* CASE: pt2' = INode pt2' op2 pt3' *)
    + (* pt2' and pt3' are valid *)
      destruct H with (n0 := size (INode pt1' op1 pt2')) (pt := INode pt1' op1 pt2')
        as (pt1''&[??]). simpl. lia. reflexivity.
      destruct H8.

      simpl in *.
      exists (INode pt1'' op2 pt3').
      split; [|split].
      * simpl. lia.
      * simpl.
        rewrite <- H2.
        rewrite <- H5.
        rewrite H8.
        rewrite <- app_assoc.
        reflexivity.
      * unfold valid_pt.
        intros.
        intro N.
        apply valid_pt_valid_st in H6 as H11.
        destruct H11.
        inv N.
        ** inv H13.
           unfold valid_pt in H6.
           destruct H6 with (o1 := op2) (o2 := o2). assumption.
           apply Head_match.
           apply INode_match.
           *** apply NT_match.
           *** assumption.
        ** unfold valid_pt in H9.
           destruct H9 with (o1 := o1) (o2 := o2). assumption.
           assumption.
        ** unfold valid_pt in H12.
           destruct H12 with (o1 := o1) (o2 := o2). assumption.
           assumption.
Qed.

(* For every sentence in a language, that sentence will still exists in the disambiguated
   language. *)
Theorem safety g w :
  language w -> dlanguage g w.
Proof.
  unfold language.
  unfold dlanguage.
  intros.
  destruct H as [pt].
  rewrite <- H.
  specialize safety_pt with (n := size pt) (g := g) (pt := pt). intros.
  destruct H0. reflexivity.
  destruct H0. destruct H1.
  exists x. split; assumption.
Qed.

End InfixGrammarTheorems.
