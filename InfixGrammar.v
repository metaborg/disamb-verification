From stdpp Require Export list.

Section InfixGrammars.
Context {L O : Type}.

(* Lexical Symbols *)
Implicit Types l : L.
(* Operand Symbols *)
Implicit Types o : O.

(*
  An Infix Expression Grammar is a CFG where all productions have the following form:

  A = LEX       (atomic expressions)
  A = A op A    (infix expressions)

  A is the only nonterminal in the grammar. LEX and op are terminals, such that no operand
  symbol op, is LEX.

  In Coq, we define an infix expression grammar is as two types L (LEX) and O (op).
  Every possible instance l of L gives a production A = l. Similarly, every possible instance
  o of O gives a production A = A o A.
 *)


(* A word is a list of terminal symbols. *)
Definition word := list (L + O).

Implicit Type w : word.

Inductive parse_tree :=
  (* Atomic Nodes for atomic expressions. The leaves of the parse tree. *)
  | ANode : L -> parse_tree
  (* Infix Nodes for infix expressions. *)
  | INode : parse_tree -> O -> parse_tree -> parse_tree.

Implicit Types t : parse_tree.

(* yield pt gives the left-to-right concatenation of all the leaves of pt. *)
Fixpoint yield t : word :=
  match t with
  | ANode lex => [inl lex]
  | INode t1 op t2 => yield t1 ++ inr op :: yield t2
  end.

(* language w states that w is a sentence in the language generated by the grammar. *)
Definition language w : Prop :=
  exists t, yield t = w. 

Inductive tree_pattern :=
  (* Nonterminal pattern node. *)
  | NTPatt
  (* Infix pattern node. *)
  | IPatt : tree_pattern -> O -> tree_pattern -> tree_pattern.

Implicit Types q : tree_pattern.
Implicit Types qs : tree_pattern -> Prop.

(* matches t q states that parse tree t matches the tree pattern q. *)
Inductive matches : parse_tree -> tree_pattern -> Prop :=
  (* Every parse tree matches the nonterminal pattern node. *)
  | NT_match t :
      matches t NTPatt
  (* Infix nodes match the infix pattern node only if its subtrees match and the operand
     word is equal. *)
  | INode_match q1 q2 t1 t2 o :
      matches t1 q1 ->
      matches t2 q2 -> 
      matches (INode t1 o t2) (IPatt q1 o q2).

(* matches t qs states that parse tree t matches one of the tree patterns in qs. *)
Definition matches_set t qs :=
  exists q, qs q /\ matches t q.

(* valid qs t states that a parse tree and all its subtrees should not match
   any patterns in qs. *)
Inductive valid qs : parse_tree -> Prop :=
  | ANode_valid lex :
      ~ matches_set (ANode lex) qs ->
      valid qs (ANode lex)
  | INode_valid t1 o t2 :
      ~ matches_set (INode t1 o t2) qs ->
      valid qs t1 ->
      valid qs t2 ->
      valid qs (INode t1 o t2).

(* Possible disambiguation rules between two operators. *)
Inductive DRelation :=
  | Left_assoc
  | Right_assoc
  | Priority.

(* Disambiguated Grammars. *)
Record dgrammar := mkDgrammar {
  rel : O -> O -> option DRelation;

  (* Associativity is symmetric. *)
  left_assoc_sym o1 o2 : rel o1 o2 = Some Left_assoc -> rel o2 o1 = Some Left_assoc;
  right_assoc_sym o1 o2 : rel o1 o2 = Some Right_assoc -> rel o2 o1 = Some Right_assoc;
  (* Priority is irreflexive and transitive. *)
  priority_irefl o : rel o o <> Some Priority;
  priority_trans o1 o2 o3 : rel o1 o2 = Some Priority ->
                            rel o2 o3 = Some Priority ->
                            rel o1 o3 = Some Priority
}.

Implicit Types g : dgrammar.

(* cpatterns g tp states that tp is a conflict pattern for the grammar g.
   A main usage is (cpattern g) to simply get the set of conflict patterns tps. *)
Inductive cpatterns g : tree_pattern -> Prop :=
  | IL o1 o2 :
      (g.(rel) o1 o2 = Some Left_assoc \/ g.(rel) o1 o2 = Some Priority) ->
      cpatterns g (IPatt NTPatt o1 (IPatt NTPatt o2 NTPatt))
  | IR o1 o2 :
      (g.(rel) o1 o2 = Some Right_assoc \/ g.(rel) o1 o2 = Some Priority) ->
      cpatterns g (IPatt (IPatt NTPatt o2 NTPatt) o1 NTPatt).

(* dlanguage g w states that w is a sentence in the disambiguated language generated by g. *)
Definition dlanguage g w : Prop :=
  exists t,
    yield t = w /\ valid (cpatterns g) t.

(* A dgrammar is safe if for all words w in the language,
   it also exists in the disambiguated language. *)
Definition safe g : Prop :=
  forall w, language w -> dlanguage g w.

(* A dgrammar is complete if a word has at most one valid corresponding parse tree. *)
Definition complete g : Prop :=
  forall t1 t2, valid (cpatterns g) t1 -> valid (cpatterns g) t2 ->
    yield t1 = yield t2 -> t1 = t2.

Definition total g : Prop :=
  forall o1 o2, exists r, g.(rel) o1 o2 = Some r.

Create HintDb igrammar.
Hint Resolve ANode_valid : igrammar.
Hint Resolve INode_valid : igrammar.
Hint Resolve NT_match : igrammar.
Hint Resolve INode_match : igrammar.
Hint Resolve IL : igrammar.
Hint Resolve IR : igrammar.

End InfixGrammars.
