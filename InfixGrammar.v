From stdpp Require Import list.
From stdpp Require Import relations.
Load "Lib/StrongInduction".

Ltac inv H := inversion H; clear H; subst.


(* 
==================================================================================
==================================================================================
==================================================================================
==================================================================================
=============================== CORE DEFINITIONS =================================
==================================================================================
==================================================================================
==================================================================================
==================================================================================
*)

Section InfixGrammars.
Context {L O : Type}.

(* Lexical Symbols *)
Implicit Types l : L.
(* Operand Symbols *)
Implicit Types o : O.

(*
  An Infix Expression Grammar is a CFG where all productions have the following form:

  A = LEX       (atomic expressions)
  A = A op A    (infix expressions)

  A is the only nonterminal in the grammar. LEX and op are terminals, such that no operand
  symbol op, is LEX.

  In Coq, we define an infix expression grammar is as two types L (LEX) and O (op).
  Every possible instance l of L gives a production A = l. Similarly, every possible instance
  o of O gives a production A = A o A.
 *)


(* A word is a list of terminal symbols. *)
Definition word := list (L + O).

Implicit Type w : word.

Inductive parse_tree :=
  (* Atomic Nodes for atomic expressions. The leaves of the parse tree. *)
  | ANode : L -> parse_tree
  (* Infix Nodes for infix expressions. *)
  | INode : parse_tree -> O -> parse_tree -> parse_tree.

Implicit Types t : parse_tree.


(* yield pt gives the left-to-right concatenation of all the leaves of pt. *)
Fixpoint yield t : word :=
  match t with
  | ANode lex => [inl lex]
  | INode t1 op t2 => yield t1 ++ inr op :: yield t2
  end.

(* language w states that w is a sentence in the language generated by the grammar. *)
Definition language w : Prop :=
  exists t, yield t = w. 

Inductive tree_pattern :=
  (* Nonterminal pattern node. *)
  | NTPatt
  (* Infix pattern node. *)
  | IPatt : tree_pattern -> O -> tree_pattern -> tree_pattern.

Implicit Types q : tree_pattern.
Implicit Types qs : tree_pattern -> Prop.

(* matches t q states that parse tree t matches the tree pattern q. *)
Inductive matches : parse_tree -> tree_pattern -> Prop :=
  (* Every parse tree matches the nonterminal pattern node. *)
  | NT_match t :
      matches t NTPatt
  (* Infix nodes match the infix pattern node only if its subtrees match and the operand
     word is equal. *)
  | INode_match q1 q2 t1 t2 o :
      matches t1 q1 ->
      matches t2 q2 -> 
      matches (INode t1 o t2) (IPatt q1 o q2).

(* matches t qs states that parse tree t matches one of the tree patterns in qs. *)
Definition matches_set t qs :=
  exists q, qs q /\ matches t q.

(* valid qs t states that a parse tree and all its subtrees should not match
   any patterns in qs. *)
Inductive valid qs : parse_tree -> Prop :=
  | ANode_valid lex :
      ~ matches_set (ANode lex) qs ->
      valid qs (ANode lex)
  | INode_valid t1 o t2 :
      ~ matches_set (INode t1 o t2) qs ->
      valid qs t1 ->
      valid qs t2 ->
      valid qs (INode t1 o t2).

(* Possible disambiguation rules between two operators. *)
Inductive DRelation :=
  | Left_assoc
  | Right_assoc
  | Priority.

(* Disambiguated Grammars. *)
Record dgrammar := mkDgrammar {
  rel : O -> O -> option DRelation;

  (* Associativity is symmetric. *)
  left_assoc_sym o1 o2 : rel o1 o2 = Some Left_assoc -> rel o2 o1 = Some Left_assoc;
  right_assoc_sym o1 o2 : rel o1 o2 = Some Right_assoc -> rel o2 o1 = Some Right_assoc;
  (* Priority is irreflexive and transitive. *)
  priority_irefl o : rel o o <> Some Priority;
  priority_trans o1 o2 o3 : rel o1 o2 = Some Priority ->
                            rel o2 o3 = Some Priority ->
                            rel o1 o3 = Some Priority
}.

Implicit Types g : dgrammar.

(* cpatterns g tp states that tp is a conflict pattern for the grammar g.
   A main usage is (cpattern g) to simply get the set of conflict patterns tps. *)
Inductive cpatterns g : tree_pattern -> Prop :=
  | IL o1 o2 :
      (g.(rel) o1 o2 = Some Left_assoc \/ g.(rel) o1 o2 = Some Priority) ->
      cpatterns g (IPatt NTPatt o1 (IPatt NTPatt o2 NTPatt))
  | IR o1 o2 :
      (g.(rel) o1 o2 = Some Right_assoc \/ g.(rel) o1 o2 = Some Priority) ->
      cpatterns g (IPatt (IPatt NTPatt o2 NTPatt) o1 NTPatt).

(* dlanguage g w states that w is a sentence in the disambiguated language generated by g. *)
Definition dlanguage g w : Prop :=
  exists t,
    yield t = w /\ valid (cpatterns g) t.

(* A dgrammar is safe if for all words w in the language,
   it also exists in the disambiguated language. *)
Definition safe g : Prop :=
  forall w, language w -> dlanguage g w.

(* A dgrammar is complete if a word has at most one valid corresponding parse tree. *)
Definition complete g : Prop :=
  forall t1 t2, valid (cpatterns g) t1 -> valid (cpatterns g) t2 ->
    yield t1 = yield t2 -> t1 = t2.

Definition total g : Prop :=
  forall o1 o2, exists r, g.(rel) o1 o2 = Some r.

Create HintDb igrammar.
Hint Resolve ANode_valid : igrammar.
Hint Resolve INode_valid : igrammar.
Hint Resolve NT_match : igrammar.
Hint Resolve INode_match : igrammar.
Hint Resolve IL : igrammar.
Hint Resolve IR : igrammar.

(* 
==================================================================================
==================================================================================
==================================================================================
==================================================================================
============================== REORDERINGS =======================================
==================================================================================
==================================================================================
==================================================================================
==================================================================================
*)

Inductive reorder_step : parse_tree -> parse_tree -> Prop :=
  | RI_LR t11 o1 t12 o t2 :
      reorder_step (INode (INode t11 o1 t12) o t2)
                   (INode t11 o1 (INode t12 o t2))
  | RI_RL t1 o t21 o2 t22 :
      reorder_step (INode t1 o (INode t21 o2 t22))
                   (INode (INode t1 o t21) o2 t22)
  | RI_t1 t1 o t2 t1' :
      reorder_step t1 t1' ->
      reorder_step (INode t1 o t2) (INode t1' o t2)
  | RI_t2 t1 o t2 t2' :
      reorder_step t2 t2' ->
      reorder_step (INode t1 o t2) (INode t1 o t2').

Definition reorder := rtc reorder_step.

Ltac super_simpl := try simpl in *; try simplify_list_eq; try reflexivity.

Lemma reorder_step_preserves_yields t t' :
  reorder_step t t' -> yield t = yield t'.
Proof.
  intros. induction H; super_simpl.
  - rewrite IHreorder_step. reflexivity.
  - rewrite IHreorder_step. reflexivity.
Qed.

Fixpoint size t : nat :=
  match t with
  | ANode l => 0
  | INode t1 o t2 => S (size t1 + size t2)
  end.

Lemma reorder_preserves_yields t t' :
  reorder t t' -> yield t = yield t'.
Proof.
  intros. induction H; auto.
  rewrite <- IHrtc.
  auto using reorder_step_preserves_yields.
Qed.

Inductive pos_tree :=
  | PANode : L -> nat -> pos_tree
  | PINode : pos_tree -> O -> nat -> pos_tree -> pos_tree.

Implicit Types pt : pos_tree.

Inductive wf_pos_tree : nat -> pos_tree -> nat -> Prop :=
  | Wfpos_PANode i l :
      wf_pos_tree i (PANode l i) (S i)
  | Wfpos_PINode i j k pt1 o pt2 :
      wf_pos_tree i pt1 j ->
      wf_pos_tree (S j) pt2 k ->
      wf_pos_tree i (PINode pt1 o j pt2) k.

Fixpoint unpos pt : parse_tree :=
  match pt with
  | PANode l _ => ANode l
  | PINode pt1 o _ pt2 => INode (unpos pt1) o (unpos pt2)
  end.

Inductive op_in_tree o i : pos_tree -> Prop :=
  | Op_Eq pt1 pt2 :
      op_in_tree o i (PINode pt1 o i pt2)
  | Op_In1 pt1 pt2 o' i' :
      op_in_tree o i pt1 ->
      op_in_tree o i (PINode pt1 o' i' pt2)
  | Op_In2 pt1 pt2 o' i' :
      op_in_tree o i pt2 ->
      op_in_tree o i (PINode pt1 o' i' pt2).

Lemma pos_yield pt n0 n1 o i :
  wf_pos_tree n0 pt n1 ->
  op_in_tree o i pt -> nth_error (yield (unpos pt)) (i - n0) = Some (inr o).
Proof.
  intros. induction H.
  - inv H0. 
  - simpl.
    inv H0.
    + 
    +
    +






(* Inductive op_in_tree o : parse_tree -> Prop :=
  | Op_Eq t1 t2 :
      op_in_tree o (INode t1 o t2)
  | Op_In1 t1 t2 o' :
      op_in_tree o t1 ->
      op_in_tree o (INode t1 o' t2)
  | Op_In2 t1 t2 o' :
      op_in_tree o t2 ->
      op_in_tree o (INode t1 o' t2).

Lemma in_app_inv {A} (l1 l2 : list A) (a : A) :
  In a (l1 ++ l2) -> In a l1 \/ In a l2.
Proof.
  intros.
  induction l1; simpl in *.
  - auto.
  - destruct H.
    + subst. auto.
    + apply IHl1 in H.
      destruct H; auto.
Qed.

Lemma op_in_yield_op_in_tree o t :
  In (inr o) (yield t) -> op_in_tree o t.
Proof.
  intros.
  induction t.
  - simpl in H.
    destruct H. discriminate H. contradiction.
  - simpl in H.
    apply in_app_inv in H.
    destruct H.
    + apply IHt1 in H.
      apply Op_In1.
      assumption.
    + apply in_inv in H.
      destruct H.
      * inv H.
        apply Op_Eq.
      * apply Op_In2.
        apply IHt2.
        assumption.
Qed.

Lemma op_in_tree_op_in_yield o t :
  op_in_tree o t -> exists t1 t2, yield t = yield (INode t1 o t2).
Proof.
  intros.
  induction H.
  - eauto.
  - destruct IHop_in_tree. destruct H0.
    simpl.
    rewrite H0.
    exists x. exists (INode x0 o' t2).
    simpl. rewrite <- app_assoc. reflexivity.
  - destruct IHop_in_tree. destruct H0.
    simpl.
    rewrite H0.
    exists (INode t1 o' x). exists x0.
    simpl. rewrite <- app_assoc. reflexivity.
Qed. *)





Lemma reorder_completes_yields_helper n t t' :
  n = size t + size t' ->
  yield t = yield t' -> reorder t t'.
Proof.
  intro. strong induction n.
  intros.
  destruct t, t'; super_simpl.
  - admit.
  - admit.
  - rename o0 into o'.
    















(* 


Section InfixGrammarTheorems.
Context {L O : Type}.
Implicit Types l : L.
Implicit Types g : dgrammar O.
Implicit Types pt : parse_tree L O.
Implicit Types w : word L O.

(* Atomic nodes are always valid under subtree exclusion. *)
Lemma valid_anode (g : dgrammar O) (lex : L) :
  valid_pt (dpattern g) (ANode lex).
Proof.
  apply ANode_valid.
  intro. inv H. inv H0. inv H1. inv H.
Qed.

(* For every parse tree, we can construct a parse tree that is
    - valid under subtree exclusion
    - has the same yield
    - has the same size
  
  We are only interested in the yield and valid parse tree, but the lemma has been made
  stronger to allow for a better induction hypothesis.

  NOTATION: We write pt' with the prime to denote the 'transformed' parse trees.
*)
Lemma safety_pt n g pt :
  size pt = n ->
  exists pt', size pt' = size pt /\ yield pt' = yield pt /\ valid_pt (dpattern g) pt'.
Proof.
  (* Proof by (strong) induction over the size of the parse tree. *)
  revert pt.
  strong induction n. intros.

  destruct pt as [lex|pt1 op1 pt2]; simpl in *.
  
  (* BASE CASE: pt = ANode lex *)
  - exists (ANode lex).
    auto using valid_anode.

  (* INDUCTIVE CASE: pt = INode pt1 pt2 *)
  - (* pt1' is the valid version of pt1 *)
    destruct H with (n0 := size pt1) (pt := pt1) as (pt1'&[??]); [lia|reflexivity|].
    destruct H2.
    (* pt2' is the valid version of pt2 *)
    destruct H with (n0 := size pt2) (pt := pt2) as (pt2'&[??]); [lia|reflexivity|].
    destruct H5.

    destruct pt2' as [lex|pt2' op2 pt3']; simpl in *.
    (* CASE: pt2' = ANode lex *)
    + exists (INode pt1' op1 (ANode lex)).
      split; [|split].
      * simpl.
        lia.
      * simpl.
        rewrite H2.
        rewrite H5.
        reflexivity.
      * apply INode_valid; [|assumption|apply valid_anode].
        intro.
        inv H7. inv H8. inv H0. inv H7. inv H15.

    (* CASE: pt2' = INode pt2' op2 pt3' *)
    + (* pt2' and pt3' are valid *)
      destruct H with (n0 := size (INode pt1' op1 pt2')) (pt := INode pt1' op1 pt2')
        as (pt1''&[??]). simpl. lia. reflexivity.
      destruct H8.

      simpl in *.
      exists (INode pt1'' op2 pt3').
      split; [|split].
      * simpl. lia.
      * simpl.
        rewrite <- H2.
        rewrite <- H5.
        rewrite H8.
        rewrite <- app_assoc.
        reflexivity.
      * apply INode_valid.

        ** intro. destruct H10 as [tp]. destruct H10.

           inv H6. destruct H15.
           unfold matches_set.
           exists tp. split. assumption.
           inv H10. inv H11.
           eauto with valid_pt.

        ** assumption.
        ** inv H6. assumption.
Qed.

(* For every sentence in a language, that sentence will still exist in the disambiguated
   language. *)
Theorem safety g w :
  language w -> dlanguage g w.
Proof.
  unfold language.
  unfold dlanguage.
  intros.
  destruct H as [pt].
  rewrite <- H.
  specialize safety_pt with (n := size pt) (g := g) (pt := pt). intros.
  destruct H0. reflexivity.
  destruct H0. destruct H1.
  exists x. split; assumption.
Qed.

(* Trivial helper lemma *)
Lemma list_length_one {A} (l1 l2 : list A) (a1 a2 : A) :
  [a1] = l1 ++ a2 :: l2 -> a1 = a2.
Proof.
  intros.
  destruct l1; simpl in H.
  - inv H. reflexivity.
  - destruct l1; inv H.
Qed.

(* If we have a total set of disambiguation rules, then our grammar is unambiguous
  (for every sentence in the language there exists exactly one corresponding parse tree). *)
Theorem completeness g pt1 pt2 :
  total g ->
  valid_pt (dpattern g) pt1 ->
  valid_pt (dpattern g) pt2 ->
  yield pt1 = yield pt2 ->
  pt1 = pt2.
Proof.
  (* Proof by induction over (the valid_pt property) of pt1 *)
  intro HTotal. unfold total in HTotal.
  intro HValidPt1.
  revert pt2.
  induction HValidPt1 as [lex|pt1_1 o1 pt1_2].

  (* BASE CASE: pt1 = lex *)
  - intros.
    destruct pt2; simpl in H1.

    (* CASE: pt2 = lex2. Proof: by yield equivalence *)
    + inv H1. reflexivity.
    (* CASE: pt2 = INode .... Proof: by discriminating yield equivalence *)
    + apply list_length_one in H1. inv H1.

  (* INDUCTIVE CASE: pt1 = INode pt1_1 o1 pt1_2 *)
  - intros.

    destruct pt2 as [lex|pt2_1 o2 pt2_2]; simpl in H1.
    (* CASE: pt2 = lex. Proof: by discriminating yield equivalence *)
    + symmetry in H1. apply list_length_one in H1.
      inv H1.
    
    (* CASE: pt2 = pt2_1 o2 pt2_2*)
    + inv H0.
      destruct pt2_2, pt1_2; simpl in H1.
      (* CASE: pt1_2 = lex1, pt2_2 = lex2. Proof: by yield equivalence and IH for pt1_1 *)
      * simplify_list_eq.
        destruct IHHValidPt1_1 with (pt2 := pt2_1); auto.
      (* CASE: pt1_2 = pt1_2_1 o pt1_2_2, pt2_2 = lex.
         Proof: by discriminating the validity of pt1 using left-assoc of o1 and o. *)
      * specialize HTotal with (o1 := o1) (o2 := o). destruct HTotal. destruct x.
        destruct H.
        unfold matches_set.
        eauto 10 with valid_pt.
      (* CASE: pt1_2 = lex, pt2_2 = pt2_2_1 o pt2_2_1.
         Proof: by discriminating the validity of pt2 using left-assoc of o2 and o. *)
      * specialize HTotal with (o1 := o2) (o2 := o). destruct HTotal. destruct x.
        destruct H5.
        unfold matches_set.
        eauto 10 with valid_pt.
      (* CASE: pt1_2 = pt1_2_1 o0 pt1_2_2, pt2_2 = pt2_2_1 o pt2_2_1.
         Proof: by discriminating the validity of pt2 using left-assoc of o2 and o. *)
      * specialize HTotal with (o1 := o2) (o2 := o). destruct HTotal. destruct x.
        destruct H5.
        unfold matches_set.
        eauto 10 with valid_pt.
Qed.

End InfixGrammarTheorems. *)
